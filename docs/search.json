[
  {
    "objectID": "analysis/index.html",
    "href": "analysis/index.html",
    "title": "Analyses",
    "section": "",
    "text": "This page lists all available analyses for the project.\n\nAnalysis 1\nAnalysis 2"
  },
  {
    "objectID": "analysis/01-explore.html",
    "href": "analysis/01-explore.html",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "",
    "text": "Load dependencies.\n\nlibrary(renv)\nrenv::load()\nrenv::restore() # Install missing librairies.\nrenv::status() # Check the project state.\n\n\nlibrary(zen4R)\nlibrary(here)\n\nDownload data from Zenodo. The data file is relatively heavy (~800Mb), this operation can take a few minutes.\n\ndoi &lt;- \"10.5281/zenodo.17962542\"\ndest_dir &lt;- here(\"data\")\n\n\nif (!dir.exists(dest_dir)) dir.create(dest_dir, recursive = TRUE)\ndownload_zenodo(doi, path = dest_dir)\nunzip(here(dest_dir, \"miste_data.zip\"), exdir = dest_dir)\n\nIf everything went well, the data should have been downloaded in data/zenodo/."
  },
  {
    "objectID": "analysis/01-explore.html#load-data",
    "href": "analysis/01-explore.html#load-data",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "2.1 Load data",
    "text": "2.1 Load data\n\nbase::load(here(dest_dir, \"zenodo\", \"processed_data\", \"poissons_env_temp.RData\"))\n\nenv\n\n# A tibble: 5,777 × 14\n   sta_id pop_id ope_id ope_date            annee distance_mer altitude\n    &lt;int&gt;  &lt;int&gt;  &lt;int&gt; &lt;dttm&gt;              &lt;dbl&gt;        &lt;int&gt;    &lt;int&gt;\n 1   9655  37720  22622 1996-09-24 10:09:00  1996           NA      305\n 2   9225  35420  16755 1998-06-19 09:30:00  1998           NA       80\n 3   9622  37544  16012 2000-05-22 14:45:00  2000          328       98\n 4   9762  38357  17091 2006-09-28 14:00:00  2006          216       31\n 5   9384  36157  17349 2006-06-21 14:30:00  2006          482      140\n 6   9712  38066  17621 2016-09-08 10:30:00  2016          400      130\n 7   9454  36580  17379 2010-09-14 15:00:00  2010          500      124\n 8   9520  36941  17079 2007-06-14 14:30:00  2007          224       37\n 9   9381  36135  17154 2006-06-20 00:00:00  2006          387      100\n10   9284  35724  17596 2016-09-29 10:00:00  2016          212       32\n# ℹ 5,767 more rows\n# ℹ 7 more variables: surface_bv &lt;dbl&gt;, distance_source &lt;dbl&gt;, largeur &lt;dbl&gt;,\n#   pente &lt;dbl&gt;, profondeur &lt;dbl&gt;, temp_juillet &lt;dbl&gt;, temp_janvier &lt;dbl&gt;\n\n\nLet’s rename column for clarity.\n\nenv &lt;- env |&gt; rename(year = annee)\n\nStation geographical coordinates are stored in points_geo_&lt;river&gt;. We visualize them over the hydrographic network.\n\nplot(net, col = \"black\", cex = 0.5)\nplot(points_geo_vilaine, col = \"red\", add = TRUE, pch = 16, cex = 0.5)"
  },
  {
    "objectID": "analysis/01-explore.html#preliminary-plots",
    "href": "analysis/01-explore.html#preliminary-plots",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "3.2. Preliminary plots",
    "text": "3.2. Preliminary plots\nLet’s plot abundance histogram for each species. As most species abundance are dominated by zeros, because of absence data, we plot log(abundance + 1) instead of raw abundances. This also implies that we will need to use zero-inflated distributions in our statistical model to account for this absence data.\n\ncatches |&gt;\n    ggplot(aes(x = abundance + 1)) + # add 1 to avoid log(0)\n    geom_histogram(binwidth = 0.5) +\n    scale_x_log10() +\n    facet_wrap(~species)\n\n\n\n\n\n\n\n\nLet’s plot abundance time series for the 10 most abundant species.\n\nn_species &lt;- 10\ncommon_species &lt;- catches |&gt;\n    group_by(species) |&gt;\n    summarise(mean_abundance = mean(abundance)) |&gt;\n    arrange(desc(mean_abundance)) |&gt;\n    slice(1:n_species) |&gt;\n    pull(species)\n\ncatches |&gt;\n    filter(species %in% common_species) |&gt;\n    group_by(year, species) |&gt;\n    summarise(mean_abundance = mean(abundance)) |&gt;\n    ggplot(aes(x = year, y = mean_abundance, colour = species)) +\n    geom_line()\n\n\n\n\n\n\n\n\nThere is no clear trend, but we can’t say much at this point because trend may be masked by sampling efforts and environmental covariates.\n\n\n\n\n\n\nNote\n\n\n\nHere it would be interesting to plot the number of operations per year to see the evolution of the sampling effort.\n\n\n\nd_eel &lt;- catches |&gt; filter(species == \"ANG\")\nd_eel.avg &lt;- d_eel |&gt;\n    group_by(pop_id) |&gt;\n    summarise(abundance_mean = mean(abundance))\ndata &lt;- inner_join(d_elev.nn, d_eel.avg, by = \"pop_id\")\n\nggplot(data, aes(x = altitude, y = abundance_mean)) +\n    geom_point() +\n    labs(\n        x = \"Altitude (m)\",\n        y = \"Eel abundance\"\n    )\n\n\n\n\n\n\n\n\nWe clearly observe the expected trend of eel abundance with altitude.\nNext, we want to model the effect of altitude, while accounting for time using INLA."
  },
  {
    "objectID": "analysis/01-explore.html#environmental-data",
    "href": "analysis/01-explore.html#environmental-data",
    "title": "RIVERSEA: Preliminary explorations",
    "section": "2.3. Environmental data",
    "text": "2.3. Environmental data\nNext, let’s focus on environmental variable that is available, so we can build a statistical model relating environment and fish abundances.\n\nenv &lt;- env |&gt; rename(year = annee)\ndata &lt;- left_join(catches, env, by = c(\"sta_id\", \"pop_id\", \"year\", \"ope_id\"))\n\nStation geographical coordinates are stored in points_geo_&lt;river&gt;. We visualize them over the hydrographic network.\n\nplot(net, col = \"black\", cex = 0.5)\nplot(points_geo_vilaine, col = \"red\", add = TRUE, pch = 16, cex = 0.5)"
  },
  {
    "objectID": "analysis/01-explore.html#eel-and-altitude",
    "href": "analysis/01-explore.html#eel-and-altitude",
    "title": "RIVERSEA: Preliminary explorations",
    "section": "2.4. Eel and altitude",
    "text": "2.4. Eel and altitude\nTo begin with, let’s focus on a single species, Eel (ANG), and environmental variable, altitude (in meter).\n\nd_env &lt;- env |&gt;\n    select(c(\"sta_id\", \"pop_id\", \"altitude\")) |&gt;\n    distinct()\nd_env |&gt; filter(is.na(altitude))\n\n# A tibble: 2 × 3\n  sta_id pop_id altitude\n   &lt;int&gt;  &lt;int&gt;    &lt;int&gt;\n1   8853  33379       NA\n2  13994  51300       NA\n\n\nWe see that we have missing values for two stations: 8853 and 13994. Next, we want to relate altitude values to geographical coordinates.\n\npts_vilaine &lt;- points_geo_vilaine |&gt;\n    select(c(\"pop_id\", \"geometry\")) |&gt;\n    left_join(d_env, by = \"pop_id\") |&gt;\n    filter(!is.na(altitude))\n\nWe see that the altitude is not measured on every sampling points, but only in 37 locations. Let’s plot them.\n\nggplot() +\n    geom_sf(data = points_geo_vilaine, color = \"grey80\", alpha = 0.5) +\n    geom_sf(data = pts_vilaine, aes(color = altitude), size = 5) +\n    scale_color_viridis_c() + # nice gradient\n    theme_minimal() +\n    labs(\n        title = \"Altitude of Sampling Points in Vilaine Basin\",\n        color = \"Altitude (m)\"\n    )\n\n\n\n\n\n\n\n\n\nd &lt;- inner_join(env, points_geo_vilaine) |&gt;\n    select(c(\"pop_id\", \"altitude\", \"geometry\")) |&gt;\n    distinct()\n\nplot(st_as_sf(d)[2])\n\n\n\n\n\n\n\n\n\nlibrary(terra)\nlibrary(tmap)\nstations &lt;- st_as_sf(d)\ngrid &lt;- terra::rast(stations, nrows = 20, ncols = 20)\nxy &lt;- terra::xyFromCell(grid, 1:ncell(grid))\ncoop &lt;- st_as_sf(as.data.frame(xy),\n    coords = c(\"x\", \"y\"),\n    crs = st_crs(stations)\n)\ntm_shape(coop) + tm_dots(fill = \"gray\") +\n    tm_shape(st_as_sf(d)) + tm_dots(\"altitude\", size = 1)\n\n\n\n\n\n\n\n\n\nlibrary(gstat)\nres &lt;- gstat(\n    formula = altitude ~ 1, locations = stations,\n    nmax = nrow(stations), set = list(idp = 1)\n)\nresp &lt;- predict(res, coop)\n\n[inverse distance weighted interpolation]\n\nresp$x &lt;- st_coordinates(resp)[, 1]\nresp$y &lt;- st_coordinates(resp)[, 2]\nresp$pred &lt;- resp$var1.pred\n\npred &lt;- terra::rasterize(resp, grid, field = \"pred\", fun = \"mean\")\ntm_shape(pred) +\n    tm_raster(col.scale = tm_scale_continuous(limits = c(0, 150), values = \"viridis\")) +\n    tm_shape(stations) +\n    tm_dots(\"altitude\", col.scale = \"viridis\")\n\n\n\n\n\n\n\n\nTODO: - Plot stations on top of hydrographic bassin. - Estimate missing values in environmental data. - Model fish abundances depending on environmental variables."
  },
  {
    "objectID": "analysis/01-explore.html#environmental-data-altitude",
    "href": "analysis/01-explore.html#environmental-data-altitude",
    "title": "RIVERSEA: Preliminary explorations",
    "section": "2.3. Environmental data (altitude)",
    "text": "2.3. Environmental data (altitude)\nNext, let’s focus on environmental variable that is available, so we can build a statistical model relating environment and fish abundances.\n\nenv &lt;- env |&gt; rename(year = annee)\ndata &lt;- left_join(catches, env, by = c(\"sta_id\", \"pop_id\", \"year\", \"ope_id\"))\n\nStation geographical coordinates are stored in points_geo_&lt;river&gt;. We visualize them over the hydrographic network.\n\nplot(net, col = \"black\", cex = 0.5)\nplot(points_geo_vilaine, col = \"red\", add = TRUE, pch = 16, cex = 0.5)\n\n\n\n\n\n\n\n\nTo begin with, let’s focus on a single environment variable: the altitude.\n\nd_env &lt;- env |&gt;\n    select(c(\"sta_id\", \"pop_id\", \"altitude\")) |&gt;\n    distinct()\nd_env |&gt; filter(is.na(altitude))\n\n# A tibble: 2 × 3\n  sta_id pop_id altitude\n   &lt;int&gt;  &lt;int&gt;    &lt;int&gt;\n1   8853  33379       NA\n2  13994  51300       NA\n\n\nWe see that we have missing values for two stations: 8853 and 13994. Next, we want to relate altitude values to geographical coordinates.\n\npts_vilaine &lt;- points_geo_vilaine |&gt;\n    select(c(\"pop_id\", \"geometry\")) |&gt;\n    left_join(d_env, by = \"pop_id\") |&gt;\n    filter(!is.na(altitude))\n\nWe see that the altitude is not measured on every sampling points, but only in 37 locations. Let’s plot them.\n\nggplot() +\n    geom_sf(data = points_geo_vilaine, color = \"grey80\", alpha = 0.5) +\n    geom_sf(data = pts_vilaine, aes(color = altitude), size = 5) +\n    labs(\n        color = \"Altitude (m)\"\n    )\n\n\n\n\n\n\n\n\nWe see in grey every location were we have sample of fish abundances, and in colour where we have altitude data. We have to interpolate altitude data for missing locations. The simplest way to do it is to the “nearest neighbour” interpolation.\nWe first build proximity polygons with the terra::voronoi function.\n\nlibrary(terra)\n\nd_elev &lt;- select(pts_vilaine, c(\"geometry\", \"altitude\"))\nd_elev.vect &lt;- terra::vect(d_elev)\nv &lt;- voronoi(d_elev.vect)\nplot(v, \"altitude\")\npoints(d_elev.vect)\n\n\n\n\n\n\n\n\n\nv.sf &lt;- st_as_sf(v)\npred &lt;- st_intersection(v.sf, points_geo_vilaine)\n\nggplot() +\n    geom_sf(data = pred, aes(color = altitude)) +\n    geom_sf(data = pts_vilaine, aes(color = altitude), size = 5) +\n    labs(\n        color = \"Altitude (m)\"\n    )\n\n\n\n\n\n\n\n\nPredicted altitudes seem consistent with the nearest neighbour interpolation. Now, that we have a prediction pipeline working we will estimate its performance using cross-validation. To do so, we will do a LOOCV (Leave-One-Out Cross-Validation).\n\nn &lt;- nrow(d_elev)\npreds &lt;- numeric(n) # Vector filled with 0s.\nfor (i in 1:n) {\n    train &lt;- d_elev[-i, ]\n    test &lt;- d_elev[i, ]\n    v_train &lt;- voronoi(terra::vect(train))\n    preds[i] &lt;- st_intersection(st_as_sf(v_train), test)$altitude\n}\nd_elev$altitude.loo &lt;- preds\n\nggplot(d_elev, aes(x = altitude, y = altitude.loo)) +\n    geom_point() +\n    geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +\n    labs(\n        x = \"Observed altitude (m)\",\n        y = \"Predicted altitude (m)\"\n    )\n\n\n\n\n\n\n\nrmse &lt;- sqrt(mean((d_elev$altitude - d_elev$altitude.loo)^2))\nrmse\n\n[1] 18.74797"
  },
  {
    "objectID": "analysis/01-explore.html#visualisation-of-altitude-data",
    "href": "analysis/01-explore.html#visualisation-of-altitude-data",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "2.2. Visualisation of altitude data",
    "text": "2.2. Visualisation of altitude data\nTo begin with, let’s focus on a single environment variable: the altitude.\n\nd_env &lt;- env |&gt;\n    select(c(\"sta_id\", \"pop_id\", \"altitude\")) |&gt;\n    distinct()\nd_env |&gt; filter(is.na(altitude))\n\n# A tibble: 2 × 3\n  sta_id pop_id altitude\n   &lt;int&gt;  &lt;int&gt;    &lt;int&gt;\n1   8853  33379       NA\n2  13994  51300       NA\n\n\nWe see that we have missing values for two stations: 8853 and 13994. Next, we want to relate altitude values to geographical coordinates.\n\npts_vilaine &lt;- points_geo_vilaine |&gt;\n    select(c(\"pop_id\", \"geometry\")) |&gt;\n    left_join(d_env, by = \"pop_id\") |&gt;\n    filter(!is.na(altitude))\npts_vilaine\n\nSimple feature collection with 37 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -2.965245 ymin: 47.46923 xmax: -1.051178 ymax: 48.3493\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   pop_id sta_id altitude                   geometry\n1   46885  12253       25 POINT (-2.429369 47.71654)\n2   46166  11854      176 POINT (-2.965245 48.32017)\n3   47601  12434       11 POINT (-1.796815 47.46923)\n4   46671  12118        9 POINT (-2.332695 47.76529)\n5   47659  12447        3  POINT (-2.142875 47.5878)\n6   47613  12436        5 POINT (-1.867647 47.70129)\n7   46484  12007       41  POINT (-2.35679 48.01553)\n8   47460  12407       48 POINT (-1.410521 47.71718)\n9   47677  12451       16 POINT (-2.563233 47.59471)\n10  47326  12380       30 POINT (-1.562385 48.03841)\n\n\nWe see that the altitude is not measured on every sampling points, but only in 37 locations. Let’s plot them.\n\nlibrary(ggplot2)\nset_theme(theme_minimal())\noptions(\n    ggplot2.continuous.colour = \"viridis\",\n    ggplot2.continuous.fill = \"viridis\"\n)\n\nggplot() +\n    geom_sf(data = points_geo_vilaine, color = \"grey80\", alpha = 0.5) +\n    geom_sf(data = pts_vilaine, aes(color = altitude), size = 5) +\n    labs(\n        color = \"Altitude (m)\"\n    )\n\n\n\n\n\n\n\n\nWe see in grey every location were we have sample of fish abundances, and in colour where we have altitude data. We have to interpolate altitude data for missing locations. The simplest way to do it is to the “nearest neighbour” interpolation."
  },
  {
    "objectID": "analysis/01-explore.html#cross-validation-of-altitude-interpolation",
    "href": "analysis/01-explore.html#cross-validation-of-altitude-interpolation",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "2.4. Cross-validation of altitude interpolation",
    "text": "2.4. Cross-validation of altitude interpolation\nNow, that we have a prediction pipeline working we will estimate its performance using cross-validation. To do so, we will do a LOOCV (Leave-One-Out Cross-Validation).\n\nn &lt;- nrow(d_elev)\npreds &lt;- numeric(n) # Vector filled with 0s.\nfor (i in 1:n) {\n    train &lt;- d_elev[-i, ]\n    test &lt;- d_elev[i, ]\n    v_train &lt;- voronoi(terra::vect(train))\n    preds[i] &lt;- st_intersection(st_as_sf(v_train), test)$altitude\n}\nd_elev$altitude.loo &lt;- preds\n\nggplot(d_elev, aes(x = altitude, y = altitude.loo)) +\n    geom_point() +\n    geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +\n    labs(\n        x = \"Observed altitude (m)\",\n        y = \"Predicted altitude (m)\"\n    )\n\n\n\n\n\n\n\nrmse &lt;- sqrt(mean((d_elev$altitude - d_elev$altitude.loo)^2))\nrmse\n\n[1] 18.74797"
  },
  {
    "objectID": "analysis/01-explore.html#interpolation-of-altitude-data",
    "href": "analysis/01-explore.html#interpolation-of-altitude-data",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "2.3. Interpolation of altitude data",
    "text": "2.3. Interpolation of altitude data\nWe first build proximity polygons with the terra::voronoi function.\n\nlibrary(terra)\n\nd_elev &lt;- select(pts_vilaine, c(\"geometry\", \"altitude\"))\nd_elev.vect &lt;- terra::vect(d_elev)\nv &lt;- voronoi(d_elev.vect)\nplot(v, \"altitude\")\npoints(d_elev.vect)\n\n\n\n\n\n\n\n\n\nv.sf &lt;- st_as_sf(v)\npred &lt;- st_intersection(v.sf, points_geo_vilaine)\nd_elev.nn &lt;- select(pred, c(\"altitude\", \"pop_id\", \"geometry\"))\n\nggplot() +\n    geom_sf(data = pred, aes(color = altitude)) +\n    geom_sf(data = pts_vilaine, aes(color = altitude), size = 5) +\n    labs(\n        color = \"Altitude (m)\"\n    )\n\n\n\n\n\n\n\n\nPredicted altitudes seem consistent with the nearest neighbour interpolation."
  },
  {
    "objectID": "analysis/01-explore.html#load-data-1",
    "href": "analysis/01-explore.html#load-data-1",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "3.1. Load data",
    "text": "3.1. Load data\n\ncatches &lt;- catches |&gt;\n    rename(\n        species = esp_code_alternatif,\n        year = annee,\n        abundance = effectif\n    )\ncatches\n\n# A tibble: 69,823 × 6\n   sta_id pop_id ope_id  year species abundance\n    &lt;int&gt;  &lt;int&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt;\n 1   8530  31870  19943  2017 TRF           159\n 2   8530  31870  19943  2017 VAI            82\n 3   8530  31870  19944  2011 TRF           217\n 4   8530  31870  19944  2011 VAI             7\n 5   8530  31870  19945  2009 TRF           232\n 6   8530  31870  19945  2009 VAI             9\n 7   8530  31870  19946  2007 TRF           213\n 8   8530  31870  19946  2007 VAI            36\n 9   8530  31870  83029  2019 TRF           126\n10   8530  31870  83029  2019 VAI           104\n# ℹ 69,813 more rows\n\nspecies_names &lt;- unique(catches$species)\n\nNext, let’s add zeros where species are not found.\n\ncatches &lt;- catches |&gt;\n    pivot_wider(\n        names_from = species,\n        values_from = abundance,\n        values_fill = list(abundance = 0)\n    ) |&gt;\n    pivot_longer(\n        cols = species_names,\n        names_to = \"species\",\n        values_to = \"abundance\"\n    )\n\ncatches\n\n# A tibble: 450,606 × 6\n   sta_id pop_id ope_id  year species abundance\n    &lt;int&gt;  &lt;int&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt;\n 1   8530  31870  19943  2017 TRF           159\n 2   8530  31870  19943  2017 VAI            82\n 3   8530  31870  19943  2017 LOF             0\n 4   8530  31870  19943  2017 CHA             0\n 5   8530  31870  19943  2017 SDF             0\n 6   8530  31870  19943  2017 PFL             0\n 7   8530  31870  19943  2017 BAF             0\n 8   8530  31870  19943  2017 CHE             0\n 9   8530  31870  19943  2017 GOU             0\n10   8530  31870  19943  2017 OBR             0\n# ℹ 450,596 more rows"
  },
  {
    "objectID": "analysis/01-explore.html#first-model",
    "href": "analysis/01-explore.html#first-model",
    "title": "RIVERSEA: Preliminary explorations",
    "section": "3.3. First model",
    "text": "3.3. First model\n\nlibrary(INLA)\n\ndata &lt;- inner_join(d_eel, d_elev.nn, by = \"pop_id\")\ndata$altitude_s &lt;- scale(data$altitude)\n\nm1 &lt;- inla(\n    abundance ~ 1 + altitude_s +\n        f(year, model = \"ar1\") +\n        f(pop_id, model = \"iid\"),\n    family = \"nbinomial\",\n    data = data,\n    control.compute = list(config = TRUE)\n)\nsummary(m1)\n\nTime used:\n    Pre = 2.31, Running = 0.726, Post = 0.146, Total = 3.18 \nFixed effects:\n              mean    sd 0.025quant 0.5quant 0.975quant   mode kld\n(Intercept)  2.068 0.216      1.646    2.066      2.508  2.066   0\naltitude_s  -1.414 0.164     -1.738   -1.413     -1.093 -1.413   0\n\nRandom effects:\n  Name    Model\n    year AR1 model\n   pop_id IID model\n\nModel hyperparameters:\n                                                         mean    sd 0.025quant\nsize for the nbinomial observations (1/overdispersion)  2.215 0.185      1.869\nPrecision for year                                     14.451 7.406      4.441\nRho for year                                            0.766 0.117      0.487\nPrecision for pop_id                                    1.457 0.412      0.805\n                                                       0.5quant 0.975quant\nsize for the nbinomial observations (1/overdispersion)    2.208      2.599\nPrecision for year                                       12.987     32.795\nRho for year                                              0.786      0.936\nPrecision for pop_id                                      1.405      2.413\n                                                         mode\nsize for the nbinomial observations (1/overdispersion)  2.197\nPrecision for year                                     10.233\nRho for year                                            0.831\nPrecision for pop_id                                    1.307\n\nMarginal log-Likelihood:  -1777.69 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n\n\ny_rep &lt;- inla.posterior.sample(1000, m1)\n\nvar_sim &lt;- sapply(y_rep, function(s) var(s$latent))\nvar_obs &lt;- var(data$abundance)\n\nc(observed = var_obs, simulated_mean = mean(var_sim))"
  },
  {
    "objectID": "analysis/01-explore.html#abundance-distribution-and-overdisperion",
    "href": "analysis/01-explore.html#abundance-distribution-and-overdisperion",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "4.1. Abundance distribution and overdisperion",
    "text": "4.1. Abundance distribution and overdisperion\nHere, we focus on the choice of the distribution of our target variable: eel abundance. We will focus particularly on overdispersion, as we know that eel distribution is zero-inflated due to absence data. For the following model, we add a random effect for stations and year. We will discuss in further details these points in following sections.\n\n4.1.1. Poisson model\nWe begin with a poisson GLM.\n\nm.poisson &lt;- inla(\n    abundance ~ 1 + altitude_s +\n        f(year, model = \"iid\") +\n        f(pop_id, model = \"iid\"),\n    family = \"poisson\",\n    data = data,\n    control.compute = list(config = TRUE)\n)\nsummary(m.poisson)\n\nTime used:\n    Pre = 1.53, Running = 0.738, Post = 0.907, Total = 3.18 \nFixed effects:\n              mean    sd 0.025quant 0.5quant 0.975quant   mode kld\n(Intercept)  1.921 0.165      1.594    1.922      2.244  1.922   0\naltitude_s  -1.404 0.169     -1.739   -1.403     -1.075 -1.403   0\n\nRandom effects:\n  Name    Model\n    year IID model\n   pop_id IID model\n\nModel hyperparameters:\n                      mean    sd 0.025quant 0.5quant 0.975quant  mode\nPrecision for year   10.86 2.719      6.395    10.57      17.03 10.03\nPrecision for pop_id  1.26 0.331      0.723     1.22       2.02  1.15\n\nMarginal log-Likelihood:  -3209.39 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n\nWe can plot the distribution of the fixed effect (altitude).\n\nmarginal.altitude &lt;- m.poisson$marginals.fixed$altitude_s\nggplot(as.data.frame(marginal.altitude)) +\n    geom_line(aes(x = x, y = y)) +\n    labs(\n        x = \"Altitude effect size\",\n        y = \"Probability\"\n    )\n\n\n\n\n\n\n\n\nWe can compute the highest posterior density (HDP) credible interval.\n\ninla.hpdmarginal(0.97, m.poisson$marginals.fixed$altitude_s)\n\n                 low      high\nlevel:0.97 -1.774432 -1.037384\n\n\nWe can also sample from the posterior distribution.\n\nm.poisson.samples &lt;- inla.posterior.sample(100, m.poisson)\n\nWe represent the sampled effect size of altitude against the marginal distribution obtained before.\n\nfun &lt;- function(...) {\n    altitude_s\n}\naltitude.sample &lt;- inla.posterior.sample.eval(fun, m.poisson.samples)\ntab &lt;- data.frame(altitude = altitude.sample[1, ])\nggplot(tab, aes(x = altitude)) +\n    geom_histogram(aes(y = after_stat(density)), bins = 18) +\n    geom_line(data = as.data.frame(marginal.altitude), aes(x = x, y = y)) +\n    labs(\n        x = \"Altitude effect size\",\n        y = \"Density\"\n    )\n\n\n\n\n\n\n\n\nNext, we want to simulate data from the model. This step is important as it allows us to see if our model makes sense or not. In particular, we identify where our model fails and improve it.\n\nalt_vals &lt;- seq(-1, 3, length.out = 100)\ny.sample &lt;- inla.posterior.sample.eval(\n    fun = function(...) {\n        mu &lt;- exp(Intercept + altitude_s * alt_vals)\n        abundance &lt;- rpois(length(mu), mu)\n    },\n    samples = m.poisson.samples\n)\n\nlibrary(bayestestR)\ny.sum &lt;- apply(y.sample, 1, function(x) {\n    y.hdi &lt;- hdi(x, ci = 0.89)\n    c(mean = mean(x), hdi_low = y.hdi$CI_low, hdi_high = y.hdi$CI_high)\n})\ndata.sim &lt;- data.frame(\n    altitude_s = alt_vals,\n    t(y.sum)\n)\n\nggplot(data.sim, aes(x = altitude_s, y = mean)) +\n    # geom_point(data = data, aes(x = altitude_s, y = abundance), colour = \"grey80\") +\n    geom_ribbon(aes(ymin = hdi_low, ymax = hdi_high), fill = \"steelblue\", alpha = 0.3) +\n    geom_line(colour = \"steelblue\") +\n    labs(\n        x = \"Scaled altitude\",\n        y = \"Eel abundance\"\n    )\n\n\n\n\n\n\n\n\nNext, we want to plot actual data against this prediction. Because we have not included spatial and temporal random effects while sampling the posterior, we are making predictions for an average site and year. Therefore, we want to average abundance data over site and year.\n\ndata.avg &lt;- data |&gt;\n    group_by(altitude_s) |&gt;\n    summarise(\n        abundance_avg = mean(abundance),\n        abundance_var = var(abundance)\n    )\ndata.avg\n\n# A tibble: 32 × 3\n   altitude_s[,1] abundance_avg abundance_var\n            &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n 1         -0.979         13.0           52.4\n 2         -0.954         35.1          416. \n 3         -0.929         50.2         1692. \n 4         -0.904         30.3          235. \n 5         -0.830         43.1         2204. \n 6         -0.780         50.1         1004. \n 7         -0.705         37.6          350. \n 8         -0.680         42.4          624. \n 9         -0.655         26.6          332. \n10         -0.630          9.44          15.3\n# ℹ 22 more rows\n\nggplot(data.sim, aes(x = altitude_s, y = mean)) +\n    geom_point(data = data.avg, aes(x = altitude_s, y = abundance_avg), colour = \"grey80\") +\n    geom_ribbon(aes(ymin = hdi_low, ymax = hdi_high), fill = \"steelblue\", alpha = 0.3) +\n    geom_line(colour = \"steelblue\") +\n    labs(\n        x = \"Scaled altitude\",\n        y = \"Eel abundance\"\n    )\n\n\n\n\n\n\n\n\nWe see that our model capture the clear decreasing trend of eel abundances with altitude.\nLet’s investigate overdispersion with a posterior predictive check.\n\ny_pred_avg &lt;- apply(y.sample, 1, mean)\ny_pred_var &lt;- apply(y.sample, 1, var)\npred_df &lt;- data.frame(\n    abundance_avg = y_pred_avg,\n    abundance_var = y_pred_var\n)\npred_df$type &lt;- \"Posterior predictive\"\npred_df$altitude_s &lt;- alt_vals\ndata.avg$type &lt;- \"Observed\"\nplot_df &lt;- rbind(pred_df, data.avg)\n\nggplot(plot_df, aes(x = abundance_avg, y = abundance_var, colour = type)) +\n    geom_point() +\n    geom_abline(slope = 1, intercept = 1) +\n    labs(\n        x = \"Observed mean abundance\",\n        y = \"Observed variance in abundace\"\n    )\n\n\n\n\n\n\n\n\nWe see clearly that observed data is overdispersed (variance &gt;&gt; mean) compared to the data generated by our model. This suggest that the poisson distribution is not suited for this task.\n\n\n4.1.2. Negative binomial model\n\ny_rep &lt;- inla.posterior.sample(1000, m1)\n\nvar_sim &lt;- sapply(y_rep, function(s) var(s$latent))\nvar_obs &lt;- var(data$abundance)\n\nc(observed = var_obs, simulated_mean = mean(var_sim))\n\n\n\n4.1.3. Model comparisons and checking overdispersion"
  },
  {
    "objectID": "analysis/01-explore.html#negative-binomial-model",
    "href": "analysis/01-explore.html#negative-binomial-model",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "4.1.2. Negative binomial model",
    "text": "4.1.2. Negative binomial model\n\ny_rep &lt;- inla.posterior.sample(1000, m1)\n\nvar_sim &lt;- sapply(y_rep, function(s) var(s$latent))\nvar_obs &lt;- var(data$abundance)\n\nc(observed = var_obs, simulated_mean = mean(var_sim))\n\n\n4.1.3. Model comparisons and checking overdispersion"
  },
  {
    "objectID": "analysis/01-explore.html#modelling-time",
    "href": "analysis/01-explore.html#modelling-time",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "4.2. Modelling time",
    "text": "4.2. Modelling time"
  },
  {
    "objectID": "analysis/01-explore.html#modelling-space",
    "href": "analysis/01-explore.html#modelling-space",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "4.3. Modelling space",
    "text": "4.3. Modelling space"
  }
]