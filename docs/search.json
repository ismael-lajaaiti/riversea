[
  {
    "objectID": "analysis/index.html",
    "href": "analysis/index.html",
    "title": "Analyses",
    "section": "",
    "text": "This page lists all available analyses for the project.\n\nAnalysis 1\nAnalysis 2"
  },
  {
    "objectID": "analysis/01-explore.html",
    "href": "analysis/01-explore.html",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "",
    "text": "Load dependencies.\n\nlibrary(renv)\nrenv::load()\nrenv::restore() # Install missing librairies.\nrenv::status() # Check the project state.\n\n\nlibrary(zen4R)\nlibrary(here)\n\nDownload data from Zenodo. The data file is relatively heavy (~800Mb), this operation can take a few minutes.\n\ndoi &lt;- \"10.5281/zenodo.17962542\"\ndest_dir &lt;- here(\"data\")\n\n\nif (!dir.exists(dest_dir)) dir.create(dest_dir, recursive = TRUE)\ndownload_zenodo(doi, path = dest_dir)\nunzip(here(dest_dir, \"miste_data.zip\"), exdir = dest_dir)\n\nIf everything went well, the data should have been downloaded in data/zenodo/."
  },
  {
    "objectID": "analysis/01-explore.html#load-data",
    "href": "analysis/01-explore.html#load-data",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "2.1 Load data",
    "text": "2.1 Load data\n\nbase::load(here(dest_dir, \"zenodo\", \"processed_data\", \"poissons_env_temp.RData\"))\n\nenv\n\n# A tibble: 5,777 × 14\n   sta_id pop_id ope_id ope_date            annee distance_mer altitude\n    &lt;int&gt;  &lt;int&gt;  &lt;int&gt; &lt;dttm&gt;              &lt;dbl&gt;        &lt;int&gt;    &lt;int&gt;\n 1   9655  37720  22622 1996-09-24 10:09:00  1996           NA      305\n 2   9225  35420  16755 1998-06-19 09:30:00  1998           NA       80\n 3   9622  37544  16012 2000-05-22 14:45:00  2000          328       98\n 4   9762  38357  17091 2006-09-28 14:00:00  2006          216       31\n 5   9384  36157  17349 2006-06-21 14:30:00  2006          482      140\n 6   9712  38066  17621 2016-09-08 10:30:00  2016          400      130\n 7   9454  36580  17379 2010-09-14 15:00:00  2010          500      124\n 8   9520  36941  17079 2007-06-14 14:30:00  2007          224       37\n 9   9381  36135  17154 2006-06-20 00:00:00  2006          387      100\n10   9284  35724  17596 2016-09-29 10:00:00  2016          212       32\n# ℹ 5,767 more rows\n# ℹ 7 more variables: surface_bv &lt;dbl&gt;, distance_source &lt;dbl&gt;, largeur &lt;dbl&gt;,\n#   pente &lt;dbl&gt;, profondeur &lt;dbl&gt;, temp_juillet &lt;dbl&gt;, temp_janvier &lt;dbl&gt;\n\n\nLet’s rename column for clarity.\n\nenv &lt;- env |&gt; rename(year = annee)\n\nStation geographical coordinates are stored in points_geo_&lt;river&gt;. We visualize them over the hydrographic network.\n\nplot(net, col = \"black\", cex = 0.5)\nplot(points_geo_vilaine, col = \"red\", add = TRUE, pch = 16, cex = 0.5)"
  },
  {
    "objectID": "analysis/01-explore.html#preliminary-plots",
    "href": "analysis/01-explore.html#preliminary-plots",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "3.2. Preliminary plots",
    "text": "3.2. Preliminary plots\nLet’s plot abundance histogram for each species. As most species abundance are dominated by zeros, because of absence data, we plot log(abundance + 1) instead of raw abundances. This also implies that we will need to use zero-inflated distributions in our statistical model to account for this absence data.\n\ncatches |&gt;\n    ggplot(aes(x = abundance + 1)) + # add 1 to avoid log(0)\n    geom_histogram(binwidth = 0.5) +\n    scale_x_log10() +\n    facet_wrap(~species)\n\n\n\n\n\n\n\n\nLet’s plot abundance time series for the 10 most abundant species.\n\nn_species &lt;- 10\ncommon_species &lt;- catches |&gt;\n    group_by(species) |&gt;\n    summarise(mean_abundance = mean(abundance)) |&gt;\n    arrange(desc(mean_abundance)) |&gt;\n    slice(1:n_species) |&gt;\n    pull(species)\n\ncatches |&gt;\n    filter(species %in% common_species) |&gt;\n    group_by(year, species) |&gt;\n    summarise(mean_abundance = mean(abundance)) |&gt;\n    ggplot(aes(x = year, y = mean_abundance, colour = species)) +\n    geom_line()\n\n\n\n\n\n\n\n\nThere is no clear trend, but we can’t say much at this point because trend may be masked by sampling efforts and environmental covariates.\n\n\n\n\n\n\nNote\n\n\n\nHere it would be interesting to plot the number of operations per year to see the evolution of the sampling effort.\n\n\n\nd_eel &lt;- catches |&gt; filter(species == \"ANG\")\nd_eel.avg &lt;- d_eel |&gt;\n    group_by(pop_id) |&gt;\n    summarise(abundance_mean = mean(abundance))\ndata &lt;- inner_join(d_elev.nn, d_eel.avg, by = \"pop_id\")\n\nggplot(data, aes(x = altitude, y = abundance_mean)) +\n    geom_point() +\n    labs(\n        x = \"Altitude (m)\",\n        y = \"Eel abundance\"\n    )\n\n\n\n\n\n\n\n\nWe clearly observe the expected trend of eel abundance with altitude.\nNext, we want to model the effect of altitude, while accounting for time using INLA."
  },
  {
    "objectID": "analysis/01-explore.html#environmental-data",
    "href": "analysis/01-explore.html#environmental-data",
    "title": "RIVERSEA: Preliminary explorations",
    "section": "2.3. Environmental data",
    "text": "2.3. Environmental data\nNext, let’s focus on environmental variable that is available, so we can build a statistical model relating environment and fish abundances.\n\nenv &lt;- env |&gt; rename(year = annee)\ndata &lt;- left_join(catches, env, by = c(\"sta_id\", \"pop_id\", \"year\", \"ope_id\"))\n\nStation geographical coordinates are stored in points_geo_&lt;river&gt;. We visualize them over the hydrographic network.\n\nplot(net, col = \"black\", cex = 0.5)\nplot(points_geo_vilaine, col = \"red\", add = TRUE, pch = 16, cex = 0.5)"
  },
  {
    "objectID": "analysis/01-explore.html#eel-and-altitude",
    "href": "analysis/01-explore.html#eel-and-altitude",
    "title": "RIVERSEA: Preliminary explorations",
    "section": "2.4. Eel and altitude",
    "text": "2.4. Eel and altitude\nTo begin with, let’s focus on a single species, Eel (ANG), and environmental variable, altitude (in meter).\n\nd_env &lt;- env |&gt;\n    select(c(\"sta_id\", \"pop_id\", \"altitude\")) |&gt;\n    distinct()\nd_env |&gt; filter(is.na(altitude))\n\n# A tibble: 2 × 3\n  sta_id pop_id altitude\n   &lt;int&gt;  &lt;int&gt;    &lt;int&gt;\n1   8853  33379       NA\n2  13994  51300       NA\n\n\nWe see that we have missing values for two stations: 8853 and 13994. Next, we want to relate altitude values to geographical coordinates.\n\npts_vilaine &lt;- points_geo_vilaine |&gt;\n    select(c(\"pop_id\", \"geometry\")) |&gt;\n    left_join(d_env, by = \"pop_id\") |&gt;\n    filter(!is.na(altitude))\n\nWe see that the altitude is not measured on every sampling points, but only in 37 locations. Let’s plot them.\n\nggplot() +\n    geom_sf(data = points_geo_vilaine, color = \"grey80\", alpha = 0.5) +\n    geom_sf(data = pts_vilaine, aes(color = altitude), size = 5) +\n    scale_color_viridis_c() + # nice gradient\n    theme_minimal() +\n    labs(\n        title = \"Altitude of Sampling Points in Vilaine Basin\",\n        color = \"Altitude (m)\"\n    )\n\n\n\n\n\n\n\n\n\nd &lt;- inner_join(env, points_geo_vilaine) |&gt;\n    select(c(\"pop_id\", \"altitude\", \"geometry\")) |&gt;\n    distinct()\n\nplot(st_as_sf(d)[2])\n\n\n\n\n\n\n\n\n\nlibrary(terra)\nlibrary(tmap)\nstations &lt;- st_as_sf(d)\ngrid &lt;- terra::rast(stations, nrows = 20, ncols = 20)\nxy &lt;- terra::xyFromCell(grid, 1:ncell(grid))\ncoop &lt;- st_as_sf(as.data.frame(xy),\n    coords = c(\"x\", \"y\"),\n    crs = st_crs(stations)\n)\ntm_shape(coop) + tm_dots(fill = \"gray\") +\n    tm_shape(st_as_sf(d)) + tm_dots(\"altitude\", size = 1)\n\n\n\n\n\n\n\n\n\nlibrary(gstat)\nres &lt;- gstat(\n    formula = altitude ~ 1, locations = stations,\n    nmax = nrow(stations), set = list(idp = 1)\n)\nresp &lt;- predict(res, coop)\n\n[inverse distance weighted interpolation]\n\nresp$x &lt;- st_coordinates(resp)[, 1]\nresp$y &lt;- st_coordinates(resp)[, 2]\nresp$pred &lt;- resp$var1.pred\n\npred &lt;- terra::rasterize(resp, grid, field = \"pred\", fun = \"mean\")\ntm_shape(pred) +\n    tm_raster(col.scale = tm_scale_continuous(limits = c(0, 150), values = \"viridis\")) +\n    tm_shape(stations) +\n    tm_dots(\"altitude\", col.scale = \"viridis\")\n\n\n\n\n\n\n\n\nTODO: - Plot stations on top of hydrographic bassin. - Estimate missing values in environmental data. - Model fish abundances depending on environmental variables."
  },
  {
    "objectID": "analysis/01-explore.html#environmental-data-altitude",
    "href": "analysis/01-explore.html#environmental-data-altitude",
    "title": "RIVERSEA: Preliminary explorations",
    "section": "2.3. Environmental data (altitude)",
    "text": "2.3. Environmental data (altitude)\nNext, let’s focus on environmental variable that is available, so we can build a statistical model relating environment and fish abundances.\n\nenv &lt;- env |&gt; rename(year = annee)\ndata &lt;- left_join(catches, env, by = c(\"sta_id\", \"pop_id\", \"year\", \"ope_id\"))\n\nStation geographical coordinates are stored in points_geo_&lt;river&gt;. We visualize them over the hydrographic network.\n\nplot(net, col = \"black\", cex = 0.5)\nplot(points_geo_vilaine, col = \"red\", add = TRUE, pch = 16, cex = 0.5)\n\n\n\n\n\n\n\n\nTo begin with, let’s focus on a single environment variable: the altitude.\n\nd_env &lt;- env |&gt;\n    select(c(\"sta_id\", \"pop_id\", \"altitude\")) |&gt;\n    distinct()\nd_env |&gt; filter(is.na(altitude))\n\n# A tibble: 2 × 3\n  sta_id pop_id altitude\n   &lt;int&gt;  &lt;int&gt;    &lt;int&gt;\n1   8853  33379       NA\n2  13994  51300       NA\n\n\nWe see that we have missing values for two stations: 8853 and 13994. Next, we want to relate altitude values to geographical coordinates.\n\npts_vilaine &lt;- points_geo_vilaine |&gt;\n    select(c(\"pop_id\", \"geometry\")) |&gt;\n    left_join(d_env, by = \"pop_id\") |&gt;\n    filter(!is.na(altitude))\n\nWe see that the altitude is not measured on every sampling points, but only in 37 locations. Let’s plot them.\n\nggplot() +\n    geom_sf(data = points_geo_vilaine, color = \"grey80\", alpha = 0.5) +\n    geom_sf(data = pts_vilaine, aes(color = altitude), size = 5) +\n    labs(\n        color = \"Altitude (m)\"\n    )\n\n\n\n\n\n\n\n\nWe see in grey every location were we have sample of fish abundances, and in colour where we have altitude data. We have to interpolate altitude data for missing locations. The simplest way to do it is to the “nearest neighbour” interpolation.\nWe first build proximity polygons with the terra::voronoi function.\n\nlibrary(terra)\n\nd_elev &lt;- select(pts_vilaine, c(\"geometry\", \"altitude\"))\nd_elev.vect &lt;- terra::vect(d_elev)\nv &lt;- voronoi(d_elev.vect)\nplot(v, \"altitude\")\npoints(d_elev.vect)\n\n\n\n\n\n\n\n\n\nv.sf &lt;- st_as_sf(v)\npred &lt;- st_intersection(v.sf, points_geo_vilaine)\n\nggplot() +\n    geom_sf(data = pred, aes(color = altitude)) +\n    geom_sf(data = pts_vilaine, aes(color = altitude), size = 5) +\n    labs(\n        color = \"Altitude (m)\"\n    )\n\n\n\n\n\n\n\n\nPredicted altitudes seem consistent with the nearest neighbour interpolation. Now, that we have a prediction pipeline working we will estimate its performance using cross-validation. To do so, we will do a LOOCV (Leave-One-Out Cross-Validation).\n\nn &lt;- nrow(d_elev)\npreds &lt;- numeric(n) # Vector filled with 0s.\nfor (i in 1:n) {\n    train &lt;- d_elev[-i, ]\n    test &lt;- d_elev[i, ]\n    v_train &lt;- voronoi(terra::vect(train))\n    preds[i] &lt;- st_intersection(st_as_sf(v_train), test)$altitude\n}\nd_elev$altitude.loo &lt;- preds\n\nggplot(d_elev, aes(x = altitude, y = altitude.loo)) +\n    geom_point() +\n    geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +\n    labs(\n        x = \"Observed altitude (m)\",\n        y = \"Predicted altitude (m)\"\n    )\n\n\n\n\n\n\n\nrmse &lt;- sqrt(mean((d_elev$altitude - d_elev$altitude.loo)^2))\nrmse\n\n[1] 18.74797"
  },
  {
    "objectID": "analysis/01-explore.html#visualisation-of-altitude-data",
    "href": "analysis/01-explore.html#visualisation-of-altitude-data",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "2.2. Visualisation of altitude data",
    "text": "2.2. Visualisation of altitude data\nTo begin with, let’s focus on a single environment variable: the altitude.\n\nd_env &lt;- env |&gt;\n    select(c(\"sta_id\", \"pop_id\", \"altitude\")) |&gt;\n    distinct()\nd_env |&gt; filter(is.na(altitude))\n\n# A tibble: 2 × 3\n  sta_id pop_id altitude\n   &lt;int&gt;  &lt;int&gt;    &lt;int&gt;\n1   8853  33379       NA\n2  13994  51300       NA\n\n\nWe see that we have missing values for two stations: 8853 and 13994. Next, we want to relate altitude values to geographical coordinates.\n\npts_vilaine &lt;- points_geo_vilaine |&gt;\n    select(c(\"pop_id\", \"geometry\")) |&gt;\n    left_join(d_env, by = \"pop_id\") |&gt;\n    filter(!is.na(altitude))\npts_vilaine\n\nSimple feature collection with 37 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -2.965245 ymin: 47.46923 xmax: -1.051178 ymax: 48.3493\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   pop_id sta_id altitude                   geometry\n1   46885  12253       25 POINT (-2.429369 47.71654)\n2   46166  11854      176 POINT (-2.965245 48.32017)\n3   47601  12434       11 POINT (-1.796815 47.46923)\n4   46671  12118        9 POINT (-2.332695 47.76529)\n5   47659  12447        3  POINT (-2.142875 47.5878)\n6   47613  12436        5 POINT (-1.867647 47.70129)\n7   46484  12007       41  POINT (-2.35679 48.01553)\n8   47460  12407       48 POINT (-1.410521 47.71718)\n9   47677  12451       16 POINT (-2.563233 47.59471)\n10  47326  12380       30 POINT (-1.562385 48.03841)\n\n\nWe see that the altitude is not measured on every sampling points, but only in 37 locations. Let’s plot them.\n\nlibrary(ggplot2)\nset_theme(theme_minimal())\noptions(\n    ggplot2.continuous.colour = \"viridis\",\n    ggplot2.continuous.fill = \"viridis\"\n)\n\nggplot() +\n    geom_sf(data = points_geo_vilaine, color = \"grey80\", alpha = 0.5) +\n    geom_sf(data = pts_vilaine, aes(color = altitude), size = 5) +\n    labs(\n        color = \"Altitude (m)\"\n    )\n\n\n\n\n\n\n\n\nWe see in grey every location were we have sample of fish abundances, and in colour where we have altitude data. We have to interpolate altitude data for missing locations. The simplest way to do it is to the “nearest neighbour” interpolation."
  },
  {
    "objectID": "analysis/01-explore.html#cross-validation-of-altitude-interpolation",
    "href": "analysis/01-explore.html#cross-validation-of-altitude-interpolation",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "2.4. Cross-validation of altitude interpolation",
    "text": "2.4. Cross-validation of altitude interpolation\nNow, that we have a prediction pipeline working we will estimate its performance using cross-validation. To do so, we will do a LOOCV (Leave-One-Out Cross-Validation).\n\nn &lt;- nrow(d_elev)\npreds &lt;- numeric(n) # Vector filled with 0s.\nfor (i in 1:n) {\n    train &lt;- d_elev[-i, ]\n    test &lt;- d_elev[i, ]\n    v_train &lt;- voronoi(terra::vect(train))\n    preds[i] &lt;- st_intersection(st_as_sf(v_train), test)$altitude\n}\nd_elev$altitude.loo &lt;- preds\n\nggplot(d_elev, aes(x = altitude, y = altitude.loo)) +\n    geom_point() +\n    geom_abline(slope = 1, intercept = 0, linetype = \"dashed\") +\n    labs(\n        x = \"Observed altitude (m)\",\n        y = \"Predicted altitude (m)\"\n    )\n\n\n\n\n\n\n\nrmse &lt;- sqrt(mean((d_elev$altitude - d_elev$altitude.loo)^2))\nrmse\n\n[1] 18.74797"
  },
  {
    "objectID": "analysis/01-explore.html#interpolation-of-altitude-data",
    "href": "analysis/01-explore.html#interpolation-of-altitude-data",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "2.3. Interpolation of altitude data",
    "text": "2.3. Interpolation of altitude data\nWe first build proximity polygons with the terra::voronoi function.\n\nlibrary(terra)\n\nd_elev &lt;- select(pts_vilaine, c(\"geometry\", \"altitude\"))\nd_elev.vect &lt;- terra::vect(d_elev)\nv &lt;- voronoi(d_elev.vect)\nplot(v, \"altitude\")\npoints(d_elev.vect)\n\n\n\n\n\n\n\n\n\nv.sf &lt;- st_as_sf(v)\npred &lt;- st_intersection(v.sf, points_geo_vilaine)\nd_elev.nn &lt;- select(pred, c(\"altitude\", \"pop_id\", \"geometry\"))\n\nggplot() +\n    geom_sf(data = pred, aes(color = altitude)) +\n    geom_sf(data = pts_vilaine, aes(color = altitude), size = 5) +\n    labs(\n        color = \"Altitude (m)\"\n    )\n\n\n\n\n\n\n\n\nPredicted altitudes seem consistent with the nearest neighbour interpolation."
  },
  {
    "objectID": "analysis/01-explore.html#load-data-1",
    "href": "analysis/01-explore.html#load-data-1",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "3.1. Load data",
    "text": "3.1. Load data\n\ncatches &lt;- catches |&gt;\n    rename(\n        species = esp_code_alternatif,\n        year = annee,\n        abundance = effectif\n    )\ncatches\n\n# A tibble: 69,823 × 6\n   sta_id pop_id ope_id  year species abundance\n    &lt;int&gt;  &lt;int&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt;\n 1   8530  31870  19943  2017 TRF           159\n 2   8530  31870  19943  2017 VAI            82\n 3   8530  31870  19944  2011 TRF           217\n 4   8530  31870  19944  2011 VAI             7\n 5   8530  31870  19945  2009 TRF           232\n 6   8530  31870  19945  2009 VAI             9\n 7   8530  31870  19946  2007 TRF           213\n 8   8530  31870  19946  2007 VAI            36\n 9   8530  31870  83029  2019 TRF           126\n10   8530  31870  83029  2019 VAI           104\n# ℹ 69,813 more rows\n\nspecies_names &lt;- unique(catches$species)\n\nNext, let’s add zeros where species are not found.\n\ncatches &lt;- catches |&gt;\n    pivot_wider(\n        names_from = species,\n        values_from = abundance,\n        values_fill = list(abundance = 0)\n    ) |&gt;\n    pivot_longer(\n        cols = species_names,\n        names_to = \"species\",\n        values_to = \"abundance\"\n    )\n\ncatches\n\n# A tibble: 450,606 × 6\n   sta_id pop_id ope_id  year species abundance\n    &lt;int&gt;  &lt;int&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;int&gt;\n 1   8530  31870  19943  2017 TRF           159\n 2   8530  31870  19943  2017 VAI            82\n 3   8530  31870  19943  2017 LOF             0\n 4   8530  31870  19943  2017 CHA             0\n 5   8530  31870  19943  2017 SDF             0\n 6   8530  31870  19943  2017 PFL             0\n 7   8530  31870  19943  2017 BAF             0\n 8   8530  31870  19943  2017 CHE             0\n 9   8530  31870  19943  2017 GOU             0\n10   8530  31870  19943  2017 OBR             0\n# ℹ 450,596 more rows"
  },
  {
    "objectID": "analysis/01-explore.html#first-model",
    "href": "analysis/01-explore.html#first-model",
    "title": "RIVERSEA: Preliminary explorations",
    "section": "3.3. First model",
    "text": "3.3. First model\n\nlibrary(INLA)\n\ndata &lt;- inner_join(d_eel, d_elev.nn, by = \"pop_id\")\ndata$altitude_s &lt;- scale(data$altitude)\n\nm1 &lt;- inla(\n    abundance ~ 1 + altitude_s +\n        f(year, model = \"ar1\") +\n        f(pop_id, model = \"iid\"),\n    family = \"nbinomial\",\n    data = data,\n    control.compute = list(config = TRUE)\n)\nsummary(m1)\n\nTime used:\n    Pre = 2.31, Running = 0.726, Post = 0.146, Total = 3.18 \nFixed effects:\n              mean    sd 0.025quant 0.5quant 0.975quant   mode kld\n(Intercept)  2.068 0.216      1.646    2.066      2.508  2.066   0\naltitude_s  -1.414 0.164     -1.738   -1.413     -1.093 -1.413   0\n\nRandom effects:\n  Name    Model\n    year AR1 model\n   pop_id IID model\n\nModel hyperparameters:\n                                                         mean    sd 0.025quant\nsize for the nbinomial observations (1/overdispersion)  2.215 0.185      1.869\nPrecision for year                                     14.451 7.406      4.441\nRho for year                                            0.766 0.117      0.487\nPrecision for pop_id                                    1.457 0.412      0.805\n                                                       0.5quant 0.975quant\nsize for the nbinomial observations (1/overdispersion)    2.208      2.599\nPrecision for year                                       12.987     32.795\nRho for year                                              0.786      0.936\nPrecision for pop_id                                      1.405      2.413\n                                                         mode\nsize for the nbinomial observations (1/overdispersion)  2.197\nPrecision for year                                     10.233\nRho for year                                            0.831\nPrecision for pop_id                                    1.307\n\nMarginal log-Likelihood:  -1777.69 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n\n\ny_rep &lt;- inla.posterior.sample(1000, m1)\n\nvar_sim &lt;- sapply(y_rep, function(s) var(s$latent))\nvar_obs &lt;- var(data$abundance)\n\nc(observed = var_obs, simulated_mean = mean(var_sim))"
  },
  {
    "objectID": "analysis/01-explore.html#abundance-distribution-and-overdisperion",
    "href": "analysis/01-explore.html#abundance-distribution-and-overdisperion",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "4.1. Abundance distribution and overdisperion",
    "text": "4.1. Abundance distribution and overdisperion\nHere, we focus on the choice of the distribution of our target variable: eel abundance. We will focus particularly on overdispersion, as we know that eel distribution is zero-inflated due to absence data. For the following model, we add a random effect for stations and year. We will discuss in further details these points in following sections.\n\n4.1.1. Poisson model\nWe begin with a poisson GLM.\n\nm.poisson &lt;- inla(\n    abundance ~ 1 + altitude_s +\n        f(year, model = \"iid\") +\n        f(pop_id, model = \"iid\"),\n    family = \"poisson\",\n    data = data,\n    control.compute = list(config = TRUE, waic = TRUE, dic = TRUE)\n)\nsummary(m.poisson)\n\nTime used:\n    Pre = 0.753, Running = 0.273, Post = 0.118, Total = 1.14 \nFixed effects:\n              mean    sd 0.025quant 0.5quant 0.975quant   mode kld\n(Intercept)  1.921 0.165      1.594    1.922      2.244  1.922   0\naltitude_s  -1.404 0.169     -1.739   -1.403     -1.075 -1.403   0\n\nRandom effects:\n  Name    Model\n    year IID model\n   pop_id IID model\n\nModel hyperparameters:\n                      mean    sd 0.025quant 0.5quant 0.975quant  mode\nPrecision for year   10.86 2.719      6.395    10.57      17.03 10.03\nPrecision for pop_id  1.26 0.331      0.723     1.22       2.02  1.15\n\nDeviance Information Criterion (DIC) ...............: 4552.01\nDeviance Information Criterion (DIC, saturated) ....: 2685.27\nEffective number of parameters .....................: -737.88\n\nWatanabe-Akaike information criterion (WAIC) ...: 10992.89\nEffective number of parameters .................: 2810.03\n\nMarginal log-Likelihood:  -3209.39 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n\nWe can plot the distribution of the fixed effect (altitude).\n\nmarginal.altitude &lt;- m.poisson$marginals.fixed$altitude_s\nggplot(as.data.frame(marginal.altitude)) +\n    geom_line(aes(x = x, y = y)) +\n    labs(\n        x = \"Altitude effect size\",\n        y = \"Probability\"\n    )\n\n\n\n\n\n\n\n\nWe can compute the highest posterior density (HDP) credible interval.\n\ninla.hpdmarginal(0.97, m.poisson$marginals.fixed$altitude_s)\n\n                 low      high\nlevel:0.97 -1.774432 -1.037384\n\n\nWe can also sample from the posterior distribution.\n\nm.poisson.samples &lt;- inla.posterior.sample(100, m.poisson)\n\nWe represent the sampled effect size of altitude against the marginal distribution obtained before.\n\nfun &lt;- function(...) {\n    altitude_s\n}\naltitude.sample &lt;- inla.posterior.sample.eval(fun, m.poisson.samples)\ntab &lt;- data.frame(altitude = altitude.sample[1, ])\nggplot(tab, aes(x = altitude)) +\n    geom_histogram(aes(y = after_stat(density)), bins = 18) +\n    geom_line(data = as.data.frame(marginal.altitude), aes(x = x, y = y)) +\n    labs(\n        x = \"Altitude effect size\",\n        y = \"Density\"\n    )\n\n\n\n\n\n\n\n\nNext, we want to simulate data from the model. This step is important as it allows us to see if our model makes sense or not. In particular, we identify where our model fails and improve it.\n\nalt_vals &lt;- seq(-1, 3, length.out = 100)\ny.sample &lt;- inla.posterior.sample.eval(\n    fun = function(...) {\n        mu &lt;- exp(Intercept + altitude_s * alt_vals)\n        abundance &lt;- rpois(length(mu), mu)\n    },\n    samples = m.poisson.samples\n)\n\nlibrary(bayestestR)\ny.sum &lt;- apply(y.sample, 1, function(x) {\n    y.hdi &lt;- hdi(x, ci = 0.89)\n    c(mean = mean(x), hdi_low = y.hdi$CI_low, hdi_high = y.hdi$CI_high)\n})\ndata.sim &lt;- data.frame(\n    altitude_s = alt_vals,\n    t(y.sum)\n)\n\nggplot(data.sim, aes(x = altitude_s, y = mean)) +\n    # geom_point(data = data, aes(x = altitude_s, y = abundance), colour = \"grey80\") +\n    geom_ribbon(aes(ymin = hdi_low, ymax = hdi_high), fill = \"steelblue\", alpha = 0.3) +\n    geom_line(colour = \"steelblue\") +\n    labs(\n        x = \"Scaled altitude\",\n        y = \"Eel abundance\"\n    )\n\n\n\n\n\n\n\n\nNext, we want to plot actual data against this prediction. Because we have not included spatial and temporal random effects while sampling the posterior, we are making predictions for an average site and year. Therefore, we want to average abundance data over site and year.\n\ndata.avg &lt;- data |&gt;\n    group_by(altitude_s) |&gt;\n    summarise(\n        abundance_avg = mean(abundance),\n        abundance_var = var(abundance)\n    )\ndata.avg\n\n# A tibble: 32 × 3\n   altitude_s[,1] abundance_avg abundance_var\n            &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n 1         -0.979         13.0           52.4\n 2         -0.954         35.1          416. \n 3         -0.929         50.2         1692. \n 4         -0.904         30.3          235. \n 5         -0.830         43.1         2204. \n 6         -0.780         50.1         1004. \n 7         -0.705         37.6          350. \n 8         -0.680         42.4          624. \n 9         -0.655         26.6          332. \n10         -0.630          9.44          15.3\n# ℹ 22 more rows\n\nggplot(data.sim, aes(x = altitude_s, y = mean)) +\n    geom_point(data = data.avg, aes(x = altitude_s, y = abundance_avg), colour = \"grey80\") +\n    geom_ribbon(aes(ymin = hdi_low, ymax = hdi_high), fill = \"steelblue\", alpha = 0.3) +\n    geom_line(colour = \"steelblue\") +\n    labs(\n        x = \"Scaled altitude\",\n        y = \"Eel abundance\"\n    )\n\n\n\n\n\n\n\n\nWe see that our model capture the clear decreasing trend of eel abundances with altitude.\nLet’s investigate overdispersion with a posterior predictive check.\n\ny_pred_avg &lt;- apply(y.sample, 1, mean)\ny_pred_var &lt;- apply(y.sample, 1, var)\npred_df &lt;- data.frame(\n    abundance_avg = y_pred_avg,\n    abundance_var = y_pred_var\n)\npred_df$type &lt;- \"Posterior predictive\"\npred_df$altitude_s &lt;- alt_vals\ndata.avg$type &lt;- \"Observed\"\nplot_df &lt;- rbind(pred_df, data.avg)\n\nggplot(plot_df, aes(x = abundance_avg, y = abundance_var, colour = type)) +\n    geom_point() +\n    geom_abline(slope = 1, intercept = 1) +\n    labs(\n        x = \"Observed mean abundance\",\n        y = \"Observed variance in abundace\"\n    )\n\n\n\n\n\n\n\n\nWe see clearly that observed data is overdispersed (variance &gt;&gt; mean) compared to the data generated by our model. This suggest that the poisson distribution is not suited for this task.\n\n\n4.1.2. Negative binomial model\nTo account for overdispersion, we will test the negative binomial distribution. Basically, we will repeat the previous section but with a model where poisson distribution is replaced with a negative binomial one.\n\nm.nbinom &lt;- inla(\n    abundance ~ 1 + altitude_s +\n        f(year, model = \"iid\") +\n        f(pop_id, model = \"iid\"),\n    family = \"nbinomial\",\n    data = data,\n    control.compute = list(config = TRUE, waic = TRUE, dic = TRUE)\n)\nsummary(m.nbinom)\n\nTime used:\n    Pre = 0.459, Running = 0.267, Post = 0.0629, Total = 0.788 \nFixed effects:\n              mean    sd 0.025quant 0.5quant 0.975quant   mode kld\n(Intercept)  2.036 0.158      1.721    2.037      2.344  2.037   0\naltitude_s  -1.412 0.164     -1.737   -1.412     -1.092 -1.412   0\n\nRandom effects:\n  Name    Model\n    year IID model\n   pop_id IID model\n\nModel hyperparameters:\n                                                        mean    sd 0.025quant\nsize for the nbinomial observations (1/overdispersion)  2.18 0.185      1.836\nPrecision for year                                     18.59 8.697      7.432\nPrecision for pop_id                                    1.46 0.411      0.806\n                                                       0.5quant 0.975quant\nsize for the nbinomial observations (1/overdispersion)     2.17       2.56\nPrecision for year                                        16.73      40.80\nPrecision for pop_id                                       1.41       2.41\n                                                        mode\nsize for the nbinomial observations (1/overdispersion)  2.16\nPrecision for year                                     13.62\nPrecision for pop_id                                    1.31\n\nDeviance Information Criterion (DIC) ...............: 3440.05\nDeviance Information Criterion (DIC, saturated) ....: 622.13\nEffective number of parameters .....................: 53.89\n\nWatanabe-Akaike information criterion (WAIC) ...: 3443.63\nEffective number of parameters .................: 50.78\n\nMarginal log-Likelihood:  -1783.55 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n\nLet’s plot the model prediction against actual data.\n\nm.nbinom.samples &lt;- inla.posterior.sample(1000, m.nbinom)\n\nalt_vals &lt;- seq(-1, 3, length.out = 100)\ny.sample &lt;- inla.posterior.sample.eval(\n    fun = function(...) {\n        mu &lt;- exp(Intercept + altitude_s * alt_vals)\n        abundance &lt;- rnbinom(length(mu), mu = mu, size = theta[1])\n    },\n    samples = m.nbinom.samples\n)\n\ny.sum &lt;- apply(y.sample, 1, function(x) {\n    y.hdi &lt;- hdi(x, ci = 0.89)\n    c(mean = mean(x), hdi_low = y.hdi$CI_low, hdi_high = y.hdi$CI_high)\n})\ndata.sim &lt;- data.frame(\n    altitude_s = alt_vals,\n    t(y.sum)\n)\n\nggplot(data.sim, aes(x = altitude_s, y = mean)) +\n    geom_point(data = data.avg, aes(x = altitude_s, y = abundance_avg), colour = \"grey80\") +\n    geom_ribbon(aes(ymin = hdi_low, ymax = hdi_high), fill = \"steelblue\", alpha = 0.3) +\n    geom_line(colour = \"steelblue\") +\n    labs(\n        x = \"Scaled altitude\",\n        y = \"Eel abundance\"\n    )\n\n\n\n\n\n\n\n\nWe see that the negative binomial distribution better account for the variance. We will stick to this distribution for now, although we could have tried other distributions. Notably, the ZIP-poisson could be useful when we have many 0s."
  },
  {
    "objectID": "analysis/01-explore.html#negative-binomial-model",
    "href": "analysis/01-explore.html#negative-binomial-model",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "4.1.2. Negative binomial model",
    "text": "4.1.2. Negative binomial model\n\ny_rep &lt;- inla.posterior.sample(1000, m1)\n\nvar_sim &lt;- sapply(y_rep, function(s) var(s$latent))\nvar_obs &lt;- var(data$abundance)\n\nc(observed = var_obs, simulated_mean = mean(var_sim))\n\n\n4.1.3. Model comparisons and checking overdispersion"
  },
  {
    "objectID": "analysis/01-explore.html#modelling-time",
    "href": "analysis/01-explore.html#modelling-time",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "4.2. Modelling time",
    "text": "4.2. Modelling time"
  },
  {
    "objectID": "analysis/01-explore.html#modelling-space",
    "href": "analysis/01-explore.html#modelling-space",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "4.3. Modelling space",
    "text": "4.3. Modelling space"
  },
  {
    "objectID": "analysis/01-explore.html#modeling-time",
    "href": "analysis/01-explore.html#modeling-time",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "4.2. Modeling time",
    "text": "4.2. Modeling time\nLet’s now focus on modelling the effect of time. To begin with, let’s inspect the raw data.\n\nggplot(data, aes(x = year, y = abundance, color = altitude_s)) +\n    geom_jitter(width = 0.2) +\n    stat_summary(fun = mean, geom = \"line\", colour = \"grey\", size = 1) +\n    labs(x = \"Year\", ylab = \"Eel abundance\", color = \"Altitude (scaled)\")\n\n\n\n\n\n\n\n\nThe plain line indicates the trend of the mean abundance over all sites. This trend is decreasing, we expect to retrieve this trend in our temporal random effects.\n\n4.2.1. IID random effect\nWe begin by assuming that year random effects are independent from one another. We expect this assumption to be wrong, but let’s start from there and then explore more realistic modeling choices.\n\nm.iid &lt;- inla(\n    abundance ~ 1 + altitude_s +\n        f(year, model = \"iid\") +\n        f(pop_id, model = \"iid\"),\n    family = \"nbinomial\",\n    data = data,\n    control.compute = list(config = TRUE, waic = TRUE)\n)\nre.year.iid &lt;- m.iid$summary.random$year\n\nHere was our first try, yet we expect some correlation from one year to another. For this reason, time random effect are often modelled with autoregressive model (AR1 if lag 1).\n\n\n4.2.2. AR1 Random effect\nWe modify the previous model changing the year random effect from IID to AR1.\n\nm.ar &lt;- inla(\n    abundance ~ 1 + altitude_s +\n        f(year, model = \"ar1\") +\n        f(pop_id, model = \"iid\"),\n    family = \"nbinomial\",\n    data = data,\n    control.compute = list(config = TRUE, waic = TRUE)\n)\nre.year.ar &lt;- m.ar$summary.random$year\n\n\n\n4.2.3. RW1 random effect\nSame with RW1 random effect.\n\nm.rw &lt;- inla(\n    abundance ~ 1 + altitude_s +\n        f(year, model = \"rw1\") +\n        f(pop_id, model = \"iid\"),\n    family = \"nbinomial\",\n    data = data,\n    control.compute = list(config = TRUE, waic = TRUE)\n)\nre.year.rw &lt;- m.rw$summary.random$year\n\n\n\n4.2.4. Model comparisons\nNow that we have the three models, we can compare them.\nFirst, we can plot random effect vs year.\n\nre.year.iid$type &lt;- \"iid\"\nre.year.ar$type &lt;- \"ar\"\nre.year.rw$type &lt;- \"rw\"\nre.year.all &lt;- rbind(re.year.iid, re.year.ar, re.year.rw)\n\nggplot(re.year.all, aes(x = ID, y = mean, color = type)) +\n    geom_hline(yintercept = 0, linetype = \"dashed\", color = \"grey50\") +\n    geom_ribbon(aes(ymin = `0.025quant`, ymax = `0.975quant`), alpha = 0.1) +\n    geom_line() +\n    geom_point() +\n    labs(\n        x = \"Year\",\n        y = \"Year random effect\",\n    )\n\n\n\n\n\n\n\n\nWe see that AR1 and RW1 produce random effects with a smooth trend. By contrast, IID random effects produces ‘chaotic’ random effects due to their independence. Second, we can inspect model WAIC, where lower values implies better out-of-sample predictive performance.\n\nm.iid$waic$waic\n\n[1] 3443.628\n\nm.ar$waic$waic\n\n[1] 3428.846\n\nm.rw$waic$waic\n\n[1] 3428.494\n\n\nWe see that AR1 and RW1 have lower WAIC signaling better predictive ability, as we could have expected.\nWe can also do a predictive check by plotting predicted trends against the observed one.\n\npred_iid &lt;- tapply(m.iid$summary.fitted.values$mean, data$year, mean)\npred_ar1 &lt;- tapply(m.ar$summary.fitted.values$mean, data$year, mean)\npred_rw1 &lt;- tapply(m.rw$summary.fitted.values$mean, data$year, mean)\n\nobs &lt;- tapply(data$abundance, data$year, mean)\n\ndf &lt;- data.frame(\n    year = sort(unique(data$year)),\n    obs = obs,\n    iid = pred_iid,\n    ar1 = pred_ar1,\n    rw1 = pred_rw1\n)\ndf &lt;- df |&gt; pivot_longer(\n    cols = c(\"obs\", \"iid\", \"ar1\", \"rw1\"),\n    names_to = \"type\",\n    values_to = \"mean_abundance\"\n)\n\nggplot(df, aes(x = year, y = mean_abundance, color = type)) +\n    geom_line() +\n    labs(\n        y = \"Mean abundance\",\n        x = \"Year\"\n    )\n\n\n\n\n\n\n\n\nHere, we see that there is no strong differences: all three models track well the observed trend. The IID model might be a bit overfitting the trend at the beginning, but otherwise there is not much to say."
  },
  {
    "objectID": "analysis/01-explore.html#modeling-space",
    "href": "analysis/01-explore.html#modeling-space",
    "title": "Modelling eel abundance in the Vilaine bassin",
    "section": "4.3. Modeling space",
    "text": "4.3. Modeling space\nNow that we have seen the different option to model time dynamics, we will focus on space.\n\n4.3.1. IID random effect\nFirst, we begin with IID random effects, assuming site are independent from one another. This assumption is probably unrealistic but still provide a useful baseline.\nWe fit the model, extract spatial random effects and join them to the dataframe containing their geographical positions.\n\nm.iid &lt;- inla(\n    abundance ~ 1 + altitude_s +\n        f(year, model = \"ar1\") +\n        f(pop_id, model = \"iid\"),\n    family = \"nbinomial\",\n    data = data,\n    control.compute = list(config = TRUE, waic = TRUE)\n)\n\nre.site.iid &lt;- m.iid$summary.random$pop_id\n\npts.re.iid &lt;- pts_vilaine |&gt; left_join(\n    re.site.iid |&gt; rename(pop_id = \"ID\"),\n    by = \"pop_id\"\n)\n\nNext, we can plot the random effect on a map, to check for spatial correlation.\n\nggplot(pts.re.iid) +\n    geom_sf(aes(color = mean), size = 2) +\n    scale_color_gradient2(\n        low = \"blue\",\n        mid = \"white\",\n        high = \"red\",\n        midpoint = 0\n    ) +\n    labs(\n        color = \"RE site\",\n    )\n\n\n\n\n\n\n\n\nWe do see a clear spatial correlation, from west to east going from negative to positive random effects. This spatial correlation in the residuals motivates the use of spatially structured residuals. We explore the different options to do so in the following subsections.\n\n\n4.3.2. SPDE random effect\nFirst step is to get site coordinates in meters, because angles distort distances between sites, which is going to bias our spatial model.\n\npts_vilaine.proj &lt;- st_transform(pts_vilaine, 2154) # Coordinates in meters.\ncoords &lt;- st_coordinates(pts_vilaine.proj)\n\nFrom these coordinates we can build the mesh using fmesher and visualise it.\n\nlibrary(fmesher)\nmesh &lt;- fm_mesh_2d_inla(loc = coords)\nplot(mesh)\npoints(coords, col = \"red\", pch = 16, cex = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe mesh can be customised to increase or decrease its resolution using additional parameters. For our simple case study, we won’t focus on these details.\n\n\nNext, we define the SPDE model and the projection matrix \\(A\\). \\(A\\) projects the spatial random field to actual observation locations.\n\nspde &lt;- inla.spde2.matern(mesh)\nA &lt;- inla.spde.make.A(mesh = mesh, loc = coords)\nspatial_index &lt;- inla.spde.make.index(\n    name = \"spatial.field\",\n    n.spde = spde$n.spde\n)\ndim(A)\n\n[1] 37 79\n\nnrow(mesh$loc)\n\n[1] 79\n\n\nWe see that \\(A\\) is of dimension (number of sites x number of mesh knots).\nBecause we have multiple observations per sites we have to expand A so the spatial random field is projected for each observations (and not locations). To do so, we have to match each observation to its location.\n\nsite_idx &lt;- match(data$pop_id, pts_vilaine$pop_id)\nA_expanded &lt;- A[site_idx, ]\ndim(A_expanded)\n\n[1] 526  79\n\nnrow(data)\n\n[1] 526\n\n\nNext, we can build the data stack which combines: data, effects (i.e. predictors) and observation matrices.\n\n# Prepare the data stack\ndata_stack &lt;- inla.stack(\n    data = list(y = data$abundance),\n    A = list(A_expanded, 1),\n    effects = list(\n        spatial.field = spatial_index,\n        data.frame(\n            intercept = rep(1, nrow(data)),\n            altitude_s = data$altitude_s,\n            year = data$year,\n            pop_id = data$pop_id\n        )\n    ),\n    tag = \"est\"\n)\n\ndata_stack\n\nData stack with\n  data:    (y), size: 526\n  effects: (spatial.field, spatial.field.group, spatial.field.repl, intercept, altitude_s, year, pop_id), size: 563\n  A:       526 times 563\n\n\nNow everything is (finally) ready to fit the model.\n\nm.spde &lt;- inla(\n    y ~ -1 + intercept + altitude_s +\n        f(year, model = \"ar1\") +\n        f(spatial.field, model = spde),\n    family = \"nbinomial\",\n    data = inla.stack.data(data_stack),\n    control.predictor = list(A = inla.stack.A(data_stack)),\n    control.compute = list(config = TRUE, waic = TRUE)\n)\n\nsummary(m.spde)\n\nTime used:\n    Pre = 0.754, Running = 0.498, Post = 0.105, Total = 1.36 \nFixed effects:\n             mean    sd 0.025quant 0.5quant 0.975quant   mode kld\nintercept   2.056 0.313      1.433    2.055      2.692  2.055   0\naltitude_s -1.396 0.229     -1.848   -1.397     -0.941 -1.397   0\n\nRandom effects:\n  Name    Model\n    year AR1 model\n   spatial.field SPDE2 model\n\nModel hyperparameters:\n                                                        mean    sd 0.025quant\nsize for the nbinomial observations (1/overdispersion)  2.21 0.185      1.867\nPrecision for year                                     14.05 7.264      4.333\nRho for year                                            0.77 0.118      0.489\nTheta1 for spatial.field                                7.51 0.397      6.691\nTheta2 for spatial.field                               -8.77 0.321     -9.373\n                                                       0.5quant 0.975quant\nsize for the nbinomial observations (1/overdispersion)    2.203      2.597\nPrecision for year                                       12.593     32.131\nRho for year                                              0.791      0.939\nTheta1 for spatial.field                                  7.526      8.253\nTheta2 for spatial.field                                 -8.783     -8.111\n                                                         mode\nsize for the nbinomial observations (1/overdispersion)  2.189\nPrecision for year                                      9.889\nRho for year                                            0.837\nTheta1 for spatial.field                                7.587\nTheta2 for spatial.field                               -8.829\n\nWatanabe-Akaike information criterion (WAIC) ...: 3431.84\nEffective number of parameters .................: 45.48\n\nMarginal log-Likelihood:  -1778.47 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n\nFirst, let’s compare the WAIC of the SPDE model with the IID one.\n\nm.iid$waic$waic\n\n[1] 3428.852\n\nm.spde$waic$waic\n\n[1] 3431.841\n\n\nWe see that they perform similarly in terms of predictive performance. This inspection doesn’t indicate that a model is clearly better than another.\n\n\n\n\n\n\nImportant\n\n\n\nWAIC is a measure of out-of-sample predictive performance. A model can be wrong (in the sense of causal structure) and predict well, while a model can be right and predict poorly. It is important to keep this fact in mind while comparing modelling performance with WAIC.\n\n\nTo go further, we extract spatial random effects and want to visual them.\n\nre.site.spde &lt;- m.spde$summary.random$spatial.field\nproj &lt;- fm_evaluator(mesh)\n\n# Get spatial field mean and sd\nspatial_mean &lt;- proj$proj$A %*% re.site.spde$mean\nspatial_sd &lt;- proj$proj$A %*% re.site.spde$sd\n\n# Create data frame for ggplot\nspatial_proj &lt;- data.frame(\n    x = rep(proj$x, length(proj$y)),\n    y = rep(proj$y, each = length(proj$x)),\n    mean = as.vector(spatial_mean),\n    sd = as.vector(spatial_sd)\n)\n\nWe also extract the edges of the river network to plot it on the subsequent figure.\n\nedges_sf &lt;- net %&gt;%\n    activate(\"edges\") %&gt;%\n    st_as_sf()\nedges_sf &lt;- st_transform(edges_sf, st_crs(pts_vilaine.proj))\n\nVisualize the spatial random effects on a map.\n\nggplot(spatial_proj, aes(x = x, y = y, fill = mean)) +\n    geom_raster() +\n    scale_fill_gradient2(\n        low = \"blue\",\n        mid = \"white\",\n        high = \"red\",\n        midpoint = 0\n    ) +\n    geom_sf(\n        data = edges_sf,\n        inherit.aes = FALSE,\n        size = 0.3,\n        alpha = 0.3\n    ) +\n    geom_sf(\n        data = pts_vilaine.proj,\n        aes(geometry = geometry),\n        inherit.aes = FALSE\n    ) +\n    labs(\n        fill = \"SPDE RE\",\n        x = \"\",\n        y = \"\"\n    )\n\n\n\n\n\n\n\n\nAs well as their uncertainty.\n\nggplot(spatial_proj, aes(x = x, y = y, fill = sd)) +\n    geom_raster() +\n    geom_sf(data = edges_sf, inherit.aes = FALSE, color = \"black\", size = 0.3) +\n    geom_sf(\n        data = pts_vilaine.proj,\n        aes(geometry = geometry),\n        inherit.aes = FALSE\n    ) +\n    labs(\n        fill = \"SD RE\",\n        x = \"\",\n        y = \"\"\n    )\n\n\n\n\n\n\n\n\nAs expected we see that uncertainty is lower near sites, and increases as we go further from them.\nWe see from plot above that SPDE makes sense for continuous process in space, as it can interpolate anywhere in the plane based on some assumed correlation structure. However, we know that eel do not live on land and therefore that their abundane is highly discontinuous. Some methods have adpated the SPDE framework to account for spatial barriers. Yet, this method doesn’t seem suited for river networks as we would have mostly barrier with a very complex topology. So let’s try something else.\n\n\n4.3.3. Besag random effect"
  }
]